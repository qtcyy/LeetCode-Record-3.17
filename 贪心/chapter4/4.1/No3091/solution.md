# 问题 3091：元素和大于等于 K 的最少操作数

## 问题重述

给定一个正整数 k，初始有一个数组 nums = [1]。可以进行以下两种操作任意次数：

1. 选择数组中的任何一个元素，将其值增加 1。
2. 复制数组中的任何一个元素，并将其添加到数组末尾。

目标是使数组元素之和大于或等于 k，求所需的最少操作次数。

## 贪心解法分析

### 思路分析

首先，我们需要理解两种操作的效果：

- 增加操作：每次操作只能增加总和 1
- 复制操作：可以快速增加数组长度，但是复制的是当前值

为了最小化操作次数，最优策略是：

1. 先通过"增加"操作将某个元素增加到一个合适的值 x
2. 然后通过"复制"操作复制这个元素 y 次
3. 最终数组元素之和为 (x) \* (y + 1) ≥ k

关键问题是确定最优的 x 和 y 值。

### 数学推导

设 x 为我们将初始元素增加到的值，即 x = 1 + (增加操作的次数)
设 y 为复制操作的次数

那么：

- 总操作次数 = (x - 1) + y
- 最终数组和 = x \* (y + 1) ≥ k

我们需要求解：

- 最小化 (x - 1) + y
- 满足 x \* (y + 1) ≥ k

假设 x \* (y + 1) = k，则 y = (k / x) - 1
总操作次数 = (x - 1) + (k / x) - 1 = x + (k / x) - 2

对于 f(x) = x + (k / x)，当 x = √k 时取最小值。但由于 x 必须是整数，我们需要检查 ⌊√k⌋ 和 ⌈√k⌉ 这两个值。

实际上，我们处理的是 k-1 而不是 k，因为初始数组已经有和为 1 了。

### 代码分析

```python
rt = max(isqrt(k - 1), 1)
return min(rt - 1 + (k - 1) // rt, rt + (k - 1) // (rt + 1))
```

这里：

- `rt` 是 sqrt(k-1) 的整数部分
- 第一个表达式 `rt - 1 + (k - 1) // rt` 计算当 x = rt + 1 时的操作次数
- 第二个表达式 `rt + (k - 1) // (rt + 1)` 计算当 x = rt + 2 时的操作次数
- 取这两种情况的最小值

### 示例分析

以 k = 11 为例：

1. rt = isqrt(10) = 3
2. 计算两种可能：
   - x = 4 时：操作数 = (4-1) + (10/4) = 3 + 2 = 5
   - x = 5 时：操作数 = (5-1) + (10/5) = 4 + 2 = 6
3. 返回最小值 5

具体操作流程：

- 将初始元素 1 增加到 4（3 次增加操作）
- 然后复制一次元素 4（1 次复制操作）
- 此时数组为 [4, 4]，总和为 8
- 再执行一次增加操作，数组变为 [5, 4]，总和为 9
- 最后再执行一次增加操作，数组变为 [6, 4]，总和为 10 + 1(最初的 1) = 11 ≥ k

总操作次数：3 + 1 + 1 = 5

### 时间复杂度

- 时间复杂度：O(1)，只需要常数级别的计算
- 空间复杂度：O(1)，只需要常数级别的存储空间

## 总结

这是一个平衡两种操作的优化问题。通过数学分析，我们找到了操作次数的最小值，关键在于找到最优的元素值和数组长度。贪心策略在这里是先将一个元素增加到理想值，然后通过复制快速扩大数组和。
