# 2948. 交换得到字典序最小的数组（Lexicographically Smallest Array After Operations）

## 问题描述

给你一个下标从 0 开始的正整数数组 `nums` 和一个正整数 `limit`。

在一次操作中，你可以选择任意两个下标 i 和 j，如果满足 |nums[i] - nums[j]| <= limit，则交换 nums[i] 和 nums[j]。

返回执行任意次操作后能得到的字典序最小的数组。

如果在数组 a 和数组 b 第一个不同的位置上，数组 a 中的对应元素比数组 b 中的对应元素的字典序更小，则认为数组 a 就比数组 b 字典序更小。例如，数组 [2,10,3] 比数组 [10,2,3] 字典序更小，下标 0 处是两个数组第一个不同的位置，且 2 < 10。

## 解题思路

### 核心思路

要得到字典序最小的数组，我们需要尽可能让较小的数放在前面的位置。但是，我们的交换操作有限制：只能交换满足 |nums[i] - nums[j]| <= limit 的两个元素。

关键发现：如果一组数之间的差值都不超过 limit，那么它们可以任意交换位置。更进一步，如果多组数可以连接起来（通过满足差值条件的数对），那么这些数可以在它们原本占据的位置上任意重新排列。

因此，我们可以将问题转化为：

1. 找出所有可以互相交换的数字组（连通分量）
2. 对于每个组，将组内的数字按升序排列，并放回它们原来的位置

### 算法步骤

1. 创建一个包含原始值和索引的数组 `a`，并按值排序
2. 遍历排序后的数组，找出所有连续的、差值不超过 limit 的数字组
3. 对于每个组，提取出原始索引并排序
4. 将组内的数字（已按值排序）放到排序后的索引位置上

### 详细实现

```python
def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:
    n = len(nums)
    # 创建 (值, 原始索引) 的数组并按值排序
    a = sorted(zip(nums, range(n)))
    ans = [0] * n
    i = 0

    while i < n:
        # 找到一个组的开始
        st = i
        i += 1
        # 寻找连续的满足条件的数字
        while i < n and a[i][0] - a[i - 1][0] <= limit:
            i += 1

        # 提取当前组
        sub = a[st:i]
        # 获取排序后的原始索引
        sub_idx = sorted(idx for _, idx in sub)

        # 将排序后的值放到排序后的索引位置
        for j, (x, _) in zip(sub_idx, sub):
            ans[j] = x

    return ans
```

### 算法解释

1. 首先，我们使用 `sorted(zip(nums, range(n)))` 创建一个包含 (值, 索引) 的数组 `a`，并按值排序。
2. 初始化结果数组 `ans` 为全 0 数组。
3. 遍历排序后的数组 `a`：
   - 对于每个位置 `i`，我们检查 `a[i][0] - a[i-1][0] <= limit` 是否成立。
   - 如果成立，则这两个数可以交换，我们将 `i` 增加并继续检查下一个数。
   - 如果不成立，则当前连续段结束，我们处理已找到的组。
4. 对于每个组 `sub`：
   - 提取原始索引并排序，得到 `sub_idx`。
   - 使用 `zip(sub_idx, sub)` 将排序后的值与排序后的索引配对。
   - 将每个值放到对应的索引位置。
5. 返回结果数组 `ans`。

### 时间复杂度和空间复杂度

- 时间复杂度：O(n log n)，主要来自排序操作。
- 空间复杂度：O(n)，用于存储辅助数组和结果数组。

## 示例分析

以 `nums = [1, 7, 6, 18, 2, 1]` 和 `limit = 3` 为例：

1. 对 `nums` 进行排序并保存原始索引：

   - `a = [(1,0), (1,5), (2,4), (6,2), (7,1), (18,3)]`

2. 遍历排序后的数组，找出所有连续的、差值不超过 limit 的数字组：

   - 第一组：`[(1,0), (1,5), (2,4)]`（因为 2-1 ≤ 3）
   - 第二组：`[(6,2), (7,1)]`（因为 7-6 ≤ 3）
   - 第三组：`[(18,3)]`

3. 对于每个组，提取原始索引并排序：

   - 第一组索引：`[0, 4, 5]`
   - 第二组索引：`[1, 2]`
   - 第三组索引：`[3]`

4. 将组内的数字放到排序后的索引位置：

   - 位置 0, 4, 5 放置值 1, 1, 2
   - 位置 1, 2 放置值 6, 7
   - 位置 3 放置值 18

5. 最终结果：`[1, 6, 7, 18, 1, 2]`

## 总结

这个解法巧妙地利用了贪心策略和连通性分析。通过找出所有可以互相交换的数字组，并在每个组内按照索引和值进行排序，我们能够得到字典序最小的结果数组。

关键点是理解：只要一组数之间的差值都不超过 limit，它们就可以在原来的位置上任意重新排列。这样，我们就可以让较小的数尽可能放在前面，从而得到字典序最小的数组。
