# 1053. 交换一次的先前排列（Previous Permutation With One Swap）

## 问题描述

给你一个正整数数组 arr（可能存在重复的元素），请你返回可在一次交换（交换两数字 arr[i] 和 arr[j] 的位置）后得到的、按字典序排列小于 arr 的最大排列。

如果无法这么操作，就请返回原数组。

## 解题思路（Solution2）

要获得字典序小于原数组的最大排列，我们需要：

1. 让排列变小（字典序小于原数组）
2. 排列尽可能大（字典序尽可能接近原数组）

### 核心思路

为了使数组变小但又尽可能大，我们需要：

1. 从右向左遍历数组，找到第一个相邻的降序对，即 arr[i-1] > arr[i]
2. 找到这样的位置后，我们需要交换 arr[i-1] 与它右侧的最大的小于 arr[i-1] 的元素

这样做的原因是：

- 要使排列变小，必须在某个位置上放置更小的数字
- 为了影响最小，这个位置应该尽可能靠右
- 交换的数字应该尽可能大（但仍小于原始数字）

### 算法步骤

1. 从右向左找到第一个 arr[i-1] > arr[i] 的位置 i
2. 如果找不到这样的位置，说明原数组已经是最小的排列，返回原数组
3. 在位置 i 之后（即区间 [i, n-1]）找到小于 arr[i-1] 的最大值的位置 j
   - 如果有多个相同的最大值，选择最左侧的（避免交换相同元素）
4. 交换 arr[i-1] 和 arr[j]

### 时间复杂度和空间复杂度

- 时间复杂度：O(n)，其中 n 是数组的长度，需要扫描数组两次
- 空间复杂度：O(1)，只使用常数额外空间

### 代码实现（C++）

```cpp
class Solution {
public:
    vector<int> prevPermOpt1(vector<int>& arr) {
        int n = arr.size();

        // 步骤1：从右向左找到第一个降序对
        int i = n - 2;
        while (i >= 0 && arr[i] <= arr[i + 1]) {
            i--;
        }

        // 如果找不到降序对，返回原数组
        if (i < 0) {
            return arr;
        }

        // 步骤2：找到arr[i]右侧小于arr[i]的最大值
        int j = n - 1;
        while (arr[j] >= arr[i] || arr[j] == arr[j - 1]) {
            j--;
        }

        // 步骤3：交换arr[i]和arr[j]
        swap(arr[i], arr[j]);

        return arr;
    }
};
```

### 注意事项

1. 需要处理重复元素。当在右侧寻找小于 arr[i-1]的最大元素时，如果有多个相同的值，应选择最左侧的元素进行交换，避免无意义的交换
2. 如果原数组已经是单调不降的（如[1,2,3,3,4]），则返回原数组
3. 交换操作会改变数组的字典序，确保我们找到的是字典序小于原数组的最大排列
