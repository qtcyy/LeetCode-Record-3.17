# 2434. 机器人用字符串解决最小字典序问题（Robot With String）

## 问题描述

给你一个字符串 s 和一个机器人，机器人当前有一个空字符串 t 。执行以下操作之一，直到 s 和 t 都变成空字符串：

1. 删除字符串 s 的**第一个**字符，并将该字符给机器人。机器人把这个字符添加到 t 的尾部。
2. 删除字符串 t 的**最后一个**字符，并将该字符给机器人。机器人将该字符写到纸上。

请你返回纸上能写出的字典序最小的字符串。

## 解题思路

这道题可以用贪心算法结合栈来解决。关键是理解什么时候应该从 s 中取字符，什么时候应该从 t 中取字符写到纸上。

### 贪心策略

为了使最终写在纸上的字符串字典序最小，我们应该遵循以下策略：

1. 如果当前 t 的末尾字符比 s 中剩余的所有字符都要小，那么应该将 t 的末尾字符写到纸上。
2. 如果 s 中还有比 t 末尾字符更小的字符，那么应该继续从 s 中取字符到 t，直到 t 的末尾字符足够小。

### 算法步骤

1. 使用计数器 `cnt` 统计 s 中每个字符的出现次数。
2. 维护一个变量 `min`，表示 s 中剩余字符的最小字符（按字典序）。
3. 使用一个栈 `st` 来模拟字符串 t。
4. 遍历 s 中的每个字符 c：
   - 将 c 的计数减 1（因为我们已经处理了这个字符）。
   - 更新 `min` 为当前 s 中剩余的最小字符。
   - 将 c 加入到栈 `st` 中。
   - 当栈不为空且栈顶字符小于等于 s 中剩余的最小字符时，将栈顶字符弹出并添加到结果中。
5. 返回最终的结果字符串。

### 算法解释

- 在每一步中，我们都面临一个选择：是继续从 s 中获取字符，还是从 t 中弹出字符写到纸上。
- 如果 t 的末尾字符（即栈顶）小于等于 s 中剩余的最小字符，那么弹出它是最优的，因为我们无法通过继续从 s 中获取字符得到更小的字符。
- 如果 t 的末尾字符大于 s 中剩余的最小字符，那么我们应该继续从 s 中获取字符，直到找到一个更小的字符或者确定无法找到更小的字符。

### 时间复杂度和空间复杂度

- 时间复杂度：O(n)，其中 n 是字符串 s 的长度。我们需要遍历一次字符串，每个字符最多入栈出栈一次。
- 空间复杂度：O(n)，用于存储栈和结果数组。

### 代码实现

```python
from collections import Counter
from string import ascii_lowercase

class Solution:
    def robotWithString(self, s: str) -> str:
        min = 0  # 代表字母表中的索引，'a'为0，'b'为1，以此类推
        st = []  # 模拟字符串t的栈
        cnt = Counter(s)  # 统计s中每个字符的出现次数
        ans = []  # 存储最终写在纸上的字符

        for c in s:
            cnt[c] -= 1  # 当前字符已处理，减少计数

            # 更新min为s中剩余字符的最小字符（按字典序）
            while min < 25 and cnt[ascii_lowercase[min]] == 0:
                min += 1

            st.append(c)  # 将当前字符加入栈（即添加到t的末尾）

            # 当栈不为空且栈顶字符小于等于s中剩余的最小字符时
            # 弹出栈顶字符并写到纸上
            while st and st[-1] <= ascii_lowercase[min]:
                ans.append(st[-1])
                st.pop()

        return "".join(ans)
```

## 示例分析

以输入 s = "bdda" 为例，让我们追踪算法执行过程：

1. 初始状态：

   - s = "bdda"
   - t = "" (st = [])
   - cnt = {'b': 1, 'd': 2, 'a': 1}
   - min = 0 (代表'a')
   - ans = []

2. 处理 'b':

   - cnt = {'b': 0, 'd': 2, 'a': 1}
   - min = 0 (剩余最小字符还是'a')
   - st = ['b']
   - 'b' > 'a'，所以不弹出

3. 处理 'd':

   - cnt = {'b': 0, 'd': 1, 'a': 1}
   - min = 0 (剩余最小字符还是'a')
   - st = ['b', 'd']
   - 'd' > 'a'，所以不弹出

4. 处理第二个 'd':

   - cnt = {'b': 0, 'd': 0, 'a': 1}
   - min = 0 (剩余最小字符还是'a')
   - st = ['b', 'd', 'd']
   - 'd' > 'a'，所以不弹出

5. 处理 'a':

   - cnt = {'b': 0, 'd': 0, 'a': 0}
   - min 更新：'a'=0 计数为 0，'b'=1 计数为 0，'c'=2 计数为 0，直到 'z'=25 计数为 0，所以 min=26
   - st = ['b', 'd', 'd', 'a']
   - 由于 min=26，任何字符都满足 <= ascii_lowercase[min]，所以开始弹出
   - 弹出 'a'，ans = ['a']
   - 弹出 'd'，ans = ['a', 'd']
   - 弹出 'd'，ans = ['a', 'd', 'd']
   - 弹出 'b'，ans = ['a', 'd', 'd', 'b']

6. 最终结果：
   - 返回 "addb"

这个结果是正确的，因为通过我们的操作，能够写出的字典序最小的字符串是 "addb"。

## 总结

这道题展示了贪心算法结合栈的应用。关键在于理解什么时候应该从栈中弹出字符（写到纸上），什么时候应该继续从字符串 s 中取字符。通过维护 s 中剩余字符的最小值，我们可以做出最优决策，得到字典序最小的结果。
