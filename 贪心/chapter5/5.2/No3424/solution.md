# LeetCode 3424: 使数组相同的最小成本

## 问题分析

这个问题提供了两个相同长度 `n` 的数组 `arr` 和 `brr`，我们需要使用两种操作将 `arr` 转换为 `brr`，并且成本最小：

1. 将 `arr` 拆分为连续子数组并以任意顺序重新排列它们（成本：`k`）
2. 将任意元素增加或减少一个正整数 `x`（成本：`x`）

这里的关键洞察是，我们可以从两种方式考虑这个问题：

- 不重新排列：直接修改每个元素
- 重新排列：支付一次成本 `k` 来重新排列元素，以最小化后续的修改成本

## 解决方案

当我们可以重新排列元素时，最优策略是将 `arr` 中最小的元素与 `brr` 中最小的元素匹配，将第二小的元素与第二小的元素匹配，依此类推。这是优化理论中"重排不等式"的直接应用。

我们需要比较两种成本：

1. 不重新排列的成本：对应元素之间绝对差值的总和
2. 重新排列的成本：`k` + 最优匹配后的绝对差值总和（通过对两个数组排序并按顺序匹配实现）

### Python 解决方案

```python
def minimumCost(arr, brr, k):
    n = len(arr)

    # 选项1：不重新排列，直接修改每个元素
    cost_without_rearrangement = sum(abs(arr[i] - brr[i]) for i in range(n))

    # 选项2：重新排列一次（成本k），然后修改元素
    # 最优重排方式是匹配排序后的元素
    sorted_arr = sorted(arr)
    sorted_brr = sorted(brr)
    cost_with_rearrangement = k + sum(abs(sorted_arr[i] - sorted_brr[i]) for i in range(n))

    # 返回两种选择中的最小值
    return min(cost_without_rearrangement, cost_with_rearrangement)
```

## 复杂度分析

- 时间复杂度：O(n log n)，主要由排序操作决定
- 空间复杂度：O(n)，用于存储排序后的数组

## 示例

让我们考虑一个例子：

- `arr = [1, 4, 8]`
- `brr = [5, 2, 6]`
- `k = 3`

不重新排列：

- 成本 = |1-5| + |4-2| + |8-6| = 4 + 2 + 2 = 8

重新排列：

- 排序后的 `arr = [1, 4, 8]`
- 排序后的 `brr = [2, 5, 6]`
- 成本 = 3 + |1-2| + |4-5| + |8-6| = 3 + 1 + 1 + 2 = 7

最小成本是 7，通过一次重新排列然后修改元素来实现。

这个解决方案正确处理了支付重新排列成本 `k` 与直接修改元素不重新排列之间的权衡。
