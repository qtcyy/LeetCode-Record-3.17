# LeetCode 2673: 使二叉树所有路径值相等的最小代价

## 问题描述

给你一个整数 n 表示一棵满二叉树里面节点的数目，节点编号从 1 到 n。根节点编号为 1，树中每个非叶子节点 i 都有两个孩子，分别是左孩子 2 _ i 和右孩子 2 _ i + 1。

树中每个节点都有一个值，用下标从 0 开始、长度为 n 的整数数组 cost 表示，其中 cost[i] 是第 i + 1 个节点的值。每次操作，你可以将树中任意节点的值增加 1。你可以执行操作任意次。

你的目标是让根到每一个叶子结点的路径值相等。请你返回最少需要执行增加操作多少次。

## 解题思路

这道题可以用贪心算法，自底向上进行处理：

1. 从最底层（叶子节点的父节点）开始向上遍历
2. 对于每个非叶子节点，计算其左右子树到叶子的路径和差值
3. 将较小的路径和增加到与较大的路径和相等，累计增加的操作次数
4. 然后将当前节点的值加上子节点中的最大路径和，作为向上传递的路径和

为什么这种做法是最优的？

- 因为我们只能增加节点值，不能减少，所以必须把所有路径和增加到最大路径和的水平
- 自底向上处理保证了在每一层，我们都使得所有到叶子节点的路径和相等
- 在处理上层节点时，我们只需关注如何让左右两棵子树的路径和相等

## 复杂度分析

- 时间复杂度: O(n)，我们只需遍历树中的所有非叶子节点一次
- 空间复杂度: O(1)，只使用了常数级额外空间

## 代码实现

```cpp
int minIncrements(int n, vector<int> &cost) {
  int operations = 0;

  // 从底向上处理（除根节点外的所有内部节点）
  for (int i = n / 2; i > 0; i--) {
    int leftChild = 2 * i;
    int rightChild = 2 * i + 1;

    // 计算左右子树路径和的差值
    int diff = abs(cost[leftChild - 1] - cost[rightChild - 1]);

    // 累加需要执行的操作次数
    operations += diff;

    // 更新当前节点的路径和（当前值 + 子节点的最大路径和）
    cost[i - 1] += max(cost[leftChild - 1], cost[rightChild - 1]);
  }

  return operations;
}
```
