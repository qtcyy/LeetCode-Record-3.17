# 判断加上 \(k\) 次 \(2^i\) 是否能得到一个数

## 问题描述

给定一个目标数 \(target\)，如何判断是否能通过最多 \(k\) 次操作，每次加上某个 \(2^i\)（其中 \(i\) 是一个整数），得到这个目标数？

这个问题可以转化为：一个数能否被表示为最多 \(k\) 个二进制位 1 的和。

## 解决方法

### 二进制表示法基础

任何非负整数都可以表示为 \(2\) 的幂的和。例如：

- \(13 = 2^3 + 2^2 + 2^0 = 8 + 4 + 1\)
- \(20 = 2^4 + 2^2 = 16 + 4\)

一个数的二进制表示中，每个位上的 1 对应一个 \(2^i\) 的贡献。

### 判断方法

判断一个数 \(target\) 是否能用最多 \(k\) 次 \(2^i\) 的加法得到，只需检查该数的二进制表示中 1 的个数是否不超过 \(k\)。

#### 算法步骤：

1. 将目标数 \(target\) 转换为二进制表示
2. 计算二进制表示中 1 的个数（称为位计数或汉明权重）
3. 如果 1 的个数不超过 \(k\)，则可以通过 \(k\) 次操作得到 \(target\)；否则不能

#### 代码实现：

```cpp
bool canObtainWithKOperations(long long target, int k) {
    // 计算target的二进制表示中1的个数
    int bitCount = 0;
    while (target > 0) {
        if (target & 1) {
            bitCount++;
        }
        target >>= 1;
    }

    // 如果1的个数不超过k，则可以得到
    return bitCount <= k;
}
```

更高效的计算位计数的方法（Brian Kernighan 算法）：

```cpp
bool canObtainWithKOperations(long long target, int k) {
    int bitCount = 0;
    while (target > 0) {
        target &= (target - 1); // 清除最低位的1
        bitCount++;
        if (bitCount > k) {
            return false; // 提前返回
        }
    }
    return true;
}
```

## 应用到原题

原题中，每次操作从 \(num1\) 减去 \((2^i + num2)\)。

要使 \(num1\) 减为 0，实际上我们需要表示 \(num1\) 为若干个 \((2^i + num2)\) 的和。可以变形为：

\[
num1 = (2^{i_1} + num2) + (2^{i_2} + num2) + ... + (2^{i_k} + num2)
\]
\[
= (2^{i_1} + 2^{i_2} + ... + 2^{i_k}) + k \cdot num2
\]

因此我们需要判断：

1. \(num1\) 是否能被 \(num2\) 整除，得到余数 \(r\)
2. 判断 \((num1 - k \cdot num2)\) 能否表示为最多 \(k\) 个 \(2^i\) 的和

### 具体算法：

1. 首先判断 \(num1\) 与 \(num2\) 的关系：
   - 如果 \(num1 < num2\)，那么需要一次操作，选择 \(i\) 使得 \(2^i + num2 = num1\)
   - 如果找不到这样的 \(i\)，则返回 -1
2. 如果 \(num1 \geq num2\)：
   - 尝试不同的操作次数 \(k\)（从 1 到一个合理的上限）
   - 检查 \((num1 - k \cdot num2)\) 是否能被表示为最多 \(k\) 个 \(2^i\) 的和
   - 如果找到这样的 \(k\)，返回 \(k\)；否则返回 -1

### 简化问题：

对于原题，我们可以对上述方法进行简化：

1. 先处理简单情况：如果 \(num1 = 0\)，直接返回 0
2. 如果 \(num2 = 0\)，则问题简化为判断 \(num1\) 的二进制表示中 1 的个数
3. 如果 \(num2 \neq 0\)：
   - 尝试操作次数 \(k\) 从 1 开始递增
   - 对于每个 \(k\)，检查 \((num1 - k \cdot num2)\) 是否为非负数，且其二进制表示中 1 的个数不超过 \(k\)
   - 找到满足条件的最小 \(k\) 并返回

通过这种方法，我们可以判断是否能通过给定次数的 \(2^i\) 加法操作达到目标值，以及需要的最少操作次数。
