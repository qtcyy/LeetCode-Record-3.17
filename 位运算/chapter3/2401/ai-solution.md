# LeetCode 2401. 最长优雅子数组

根据题目描述，我们需要找出最长的「优雅子数组」，其中「优雅子数组」定义为：子数组中任意两个不同位置的元素按位与（AND）运算结果为 0。

## 题目分析

这道题目可以使用滑动窗口算法来解决。关键思路是：

对于优雅子数组，任意两个数按位与均为 0，这意味着子数组中的数二进制位按位加起来，每一位二进制位最多为 1。也就是说，在某个集合中，某个二进制位不能超过 1。

例如，输入数组 [1,3,8,48,10]，其中 [3,8,48] 是最长的优雅子数组，因为：

- 3 AND 8 = 0
- 3 AND 48 = 0
- 8 AND 48 = 0

## 解题思路

1. 使用滑动窗口，维护左右指针
2. 用一个变量 `used` 表示当前窗口中已经使用的二进制位
3. 当加入新元素时，检查是否与当前窗口中的元素有重叠的二进制位
4. 如果有重叠，则收缩左侧窗口，直到没有重叠

## 代码实现

## 算法详解

### 算法思想

这个问题的关键点在于理解「优雅子数组」的定义 - 子数组中任意两个不同位置的元素按位与为 0。从二进制角度来看，这意味着子数组中每个二进制位最多被设置一次。

我们可以使用滑动窗口算法配合位运算来解决：

1. 维护一个变量 `used`，表示当前窗口中所有数字的二进制位集合
2. 对于每个新加入的数字 `nums[right]`：
   - 检查它是否与当前窗口中的数字有重叠的二进制位
   - 如果有重叠，则从左侧收缩窗口，直到没有冲突

### 示例演示

以 [1,3,8,48,10] 为例：

1. 初始状态：`left = 0`, `right = 0`, `used = 0`, `maxLength = 1`
2. 处理 `nums[0] = 1`：
   - 没有冲突，`used = 1`，长度 = 1
3. 处理 `nums[1] = 3`：
   - 3 的二进制是 11，与 `used = 1` 有冲突
   - 移除 `nums[0] = 1`，`left = 1`，`used = 0`
   - 加入 3，`used = 3`，长度 = 1
4. 处理 `nums[2] = 8`：
   - 8 的二进制是 1000，与 `used = 3` 没有冲突
   - `used = 11`，长度 = 2
5. 处理 `nums[3] = 48`：
   - 48 的二进制是 110000，与 `used = 11` 没有冲突
   - `used = 110011`，长度 = 3
6. 处理 `nums[4] = 10`：
   - 10 的二进制是 1010，与 `used = 110011` 有冲突
   - 移除 `nums[1] = 3`，`left = 2`，`used = 110000`
   - 仍有冲突，继续移除 `nums[2] = 8`，`left = 3`，`used = 110000`
   - 加入 10，`used = 111010`，长度 = 2

最终，最长优雅子数组的长度为 3，对应子数组 [3,8,48]。

### 复杂度分析

- 时间复杂度：O(n)，其中 n 是数组长度。虽然有两层循环，但每个元素最多被添加和移除一次，所以总体操作次数是线性的。
- 空间复杂度：O(1)，只使用了常数额外空间。

### 代码优化建议

上面的实现已经比较高效，以下是一些可能的优化或变体：

1. 如果输入数组非常大，可以考虑提前检查是否有简单情况，例如数组长度为 1 时直接返回 1。
2. 在 C++实现中，可以使用类型别名提高代码可读性：`using ll = long long;`，特别是当可能有较大整数时。

## 总结

这道「最长优雅子数组」问题是滑动窗口技术的典型应用。关键洞察是将问题转化为位运算，通过维护一个表示当前窗口中已使用二进制位的变量，高效地检测和解决冲突。

该算法具有线性时间复杂度，是解决此类问题的最优解法之一。无论是 C++还是 Python 实现，核心思想都是一致的，只是在语法细节上有所不同。
