# LeetCode 1734. 解码异或后的排列

## 问题理解

这道题给我们一个长度为`n-1`的整数数组`encoded`，它是通过对一个长度为`n`的排列`perm`（包含 1 到 n 的所有正整数）进行编码得到的。编码规则是：`encoded[i] = perm[i] XOR perm[i+1]`。题目要求我们根据`encoded`数组恢复原始的`perm`数组。另外，题目告诉我们`n`是奇数。

## 解题思路

要解决这个问题，我需要利用异或运算的一些性质和题目中给出的条件来找到恢复排列的方法。关键在于确定`perm[0]`的值，因为一旦我们知道了`perm[0]`，就可以利用`encoded`数组递推出整个`perm`数组。

### 关键观察

1. 由于`perm`是 1 到 n 的排列，所以所有元素的异或值等于`1 ^ 2 ^ 3 ^ ... ^ n`
2. 题目中指出 n 是奇数，这一点非常重要
3. `encoded[i] = perm[i] ^ perm[i+1]`，这意味着相邻的`perm`元素可以通过异或关系连接起来

### 解题步骤

1. 计算`1 ^ 2 ^ 3 ^ ... ^ n`的值，这是整个`perm`数组所有元素的异或值
2. 对`encoded`中所有奇数位置的元素（即`encoded[1]`, `encoded[3]`, ..., `encoded[n-2]`）进行异或，得到的结果是`perm[1] ^ perm[2] ^ ... ^ perm[n-1]`
3. 将步骤 1 和步骤 2 的结果进行异或，得到`perm[0]`的值
4. 有了`perm[0]`后，可以使用递推关系`perm[i+1] = encoded[i] ^ perm[i]`计算整个`perm`数组

现在让我实现这个算法：

## 解题分析

从网络搜索的结果可以看出，我们的解决方案是正确的。让我详细解释一下为什么这个算法能够工作：

### 异或运算的基本性质

首先，我们需要了解几个异或运算的重要性质：

1. 交换律：a ^ b = b ^ a
2. 结合律：(a ^ b) ^ c = a ^ (b ^ c)
3. 任何数与自身异或等于 0：a ^ a = 0
4. 任何数与 0 异或等于自身：a ^ 0 = a

### 关键突破

由于我们知道`perm`是 1 到 n 的排列，且 n 是奇数，我们可以利用以下关系：

1. `perm`的所有元素异或等于 1 到 n 的所有数字异或：

   ```
   perm[0] ^ perm[1] ^ ... ^ perm[n-1] = 1 ^ 2 ^ ... ^ n
   ```

2. 观察`encoded`数组的奇数位置元素，即`encoded[1]`, `encoded[3]`, ...:

   ```
   encoded[1] = perm[1] ^ perm[2]
   encoded[3] = perm[3] ^ perm[4]
   ...
   encoded[n-2] = perm[n-2] ^ perm[n-1]
   ```

3. 对这些奇数位置元素进行异或，得到：

   ```
   encoded[1] ^ encoded[3] ^ ... ^ encoded[n-2] = perm[1] ^ perm[2] ^ perm[3] ^ ... ^ perm[n-1]
   ```

   注意因为 n 是奇数，所以每对`perm`元素都会成对出现，除了第一个`perm[1]`和最后一个`perm[n-1]`。其他元素都会因为异或运算的性质而被抵消。

4. 将上面的两个等式异或，我们得到：

   ```
   (perm[0] ^ perm[1] ^ ... ^ perm[n-1]) ^ (perm[1] ^ ... ^ perm[n-1]) = (1 ^ 2 ^ ... ^ n) ^ (encoded[1] ^ encoded[3] ^ ... ^ encoded[n-2])
   ```

   由于`a ^ a = 0`的性质，`perm[1]`到`perm[n-1]`会在左侧被抵消，只剩下`perm[0]`：

   ```
   perm[0] = (1 ^ 2 ^ ... ^ n) ^ (encoded[1] ^ encoded[3] ^ ... ^ encoded[n-2])
   ```

5. 一旦我们有了`perm[0]`，我们就可以利用`encoded`数组递推得到整个`perm`数组：
   ```
   perm[i+1] = encoded[i] ^ perm[i]
   ```

## 解决方案的时间复杂度和空间复杂度

- **时间复杂度**：O(n)，我们需要遍历 1 到 n 的所有数字以及 encoded 数组
- **空间复杂度**：O(n)，用于存储结果数组 perm

## 举例说明

让我们以示例 1 为例，`encoded = [3,1]`：

1. n = 3（数组长度+1）
2. 计算 1 到 3 的异或：1 ^ 2 ^ 3 = 0
3. 计算 encoded 中奇数位置元素的异或：encoded[1] = 1
4. 计算 perm[0]：0 ^ 1 = 1
5. 递推计算 perm[1]：encoded[0] ^ perm[0] = 3 ^ 1 = 2
6. 递推计算 perm[2]：encoded[1] ^ perm[1] = 1 ^ 2 = 3
7. 返回[1,2,3]

## 总结

这道题的关键在于发现当 n 为奇数时，我们可以通过巧妙地利用异或运算的性质，找到原始排列的第一个元素。通过观察到 encoded 数组中奇数位置元素的异或结果与 1 到 n 的异或结果之间的关系，我们能够恢复出完整的排列。

这是一个很好的位运算应用题，它展示了如何利用异或运算的特性来解决看似复杂的问题。在编码竞赛中，理解并灵活运用这些位运算技巧可以帮助我们高效地解决许多问题。
