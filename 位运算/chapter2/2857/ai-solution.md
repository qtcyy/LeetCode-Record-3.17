# LeetCode 2857. 统计距离为 k 的点对

## 问题理解

这道题给我们一组二维平面上的点坐标`coordinates`，以及一个整数`k`。题目中定义两点`(x1, y1)`和`(x2, y2)`之间的距离为`(x1 XOR x2) + (y1 XOR y2)`，其中 XOR 是按位异或运算。我们需要计算有多少对点`(i, j)`满足`i < j`且它们之间的距离恰好为`k`。

## 解题思路分析

这题的关键在于理解 XOR（异或）操作的特性，以及如何高效地找到满足条件的点对。

### 异或的关键性质

对于异或运算，有一个重要性质：如果`a XOR b = c`，那么`a XOR c = b`。

利用这个性质，我们可以转换问题。对于每一个点`(x, y)`，我们想找到之前处理过的点`(px, py)`，使得它们的距离为`k`：

```
(x XOR px) + (y XOR py) = k
```

我们可以枚举所有可能的`a`，使得`a + b = k`（其中`b = k - a`）。对于每个这样的组合，我们需要检查是否存在一个之前的点`(px, py)`满足：

```
x XOR px = a
y XOR py = b
```

根据异或的性质，这相当于检查点`(x XOR a, y XOR b)`是否在我们已经处理过的点中。

## 解法详解

### 算法原理

这道题的核心思路是利用异或运算的性质和哈希表来高效计算满足条件的点对数量。从网络搜索结果中可以看到，题目定义了两点`(x1, y1)`和`(x2, y2)`之间的距离为`(x1 XOR x2) + (y1 XOR y2)`，我们需要找出距离正好为`k`的点对数量。

解题的关键在于理解，如果我们已经处理了一些点，现在处理到点`(x, y)`，我们希望找到之前的点`(px, py)`使得它们之间的距离为`k`。这等价于寻找满足下面条件的点：

```
(x XOR px) + (y XOR py) = k
```

让我们定义：

- a = x XOR px
- b = y XOR py

这样，我们需要找的是所有满足`a + b = k`的`(a, b)`组合。对于每个这样的组合，我们可以通过异或的性质计算出对应的点：

```
px = x XOR a
py = y XOR b
```

然后我们检查点`(px, py)`是否在我们已经处理过的点集合中。

### 代码实现解释

我们的算法步骤如下：

1. 使用哈希表存储已经处理过的点及其出现次数
2. 对于每个点`(x, y)`，枚举所有可能的`a`值（从 0 到 k）
3. 计算`b = k - a`，然后计算需要查找的点`(px, py) = (x XOR a, y XOR b)`
4. 检查这个点是否在哈希表中，如果存在，将其出现次数加到结果中
5. 将当前点`(x, y)`加入哈希表中

这种方法的时间复杂度是`O(n * k)`，其中`n`是点的数量，`k`是给定的距离值。空间复杂度为`O(n)`，用于存储哈希表。

### 示例解析

让我用一个例子来说明算法的执行过程：输入：coordinates = [[1,2],[4,2],[1,3],[5,2]]，k = 5

1. 处理点(1,2)：

   - 哈希表为空，点(1,2)添加到哈希表
   - 哈希表：{(1,2): 1}

2. 处理点(4,2)：

   - 枚举 a 从 0 到 5
   - 当 a=5，b=0 时：
     - px = 4 XOR 5 = 1，py = 2 XOR 0 = 2
     - 检查点(1,2)，在哈希表中找到，计数+1
   - 点(4,2)添加到哈希表
   - 哈希表：{(1,2): 1, (4,2): 1}，计数=1

3. 处理点(1,3)：

   - 枚举 a 从 0 到 5
   - 当 a=5，b=0 时：
     - px = 1 XOR 5 = 4，py = 3 XOR 0 = 3
     - 点(4,3)不在哈希表中
   - 当 a=0，b=5 时：
     - px = 1 XOR 0 = 1，py = 3 XOR 5 = 6
     - 点(1,6)不在哈希表中
   - ...其他组合也不匹配
   - 点(1,3)添加到哈希表
   - 哈希表：{(1,2): 1, (4,2): 1, (1,3): 1}，计数仍为 1

4. 处理点(5,2)：
   - 枚举 a 从 0 到 5
   - 当 a=4，b=1 时：
     - px = 5 XOR 4 = 1，py = 2 XOR 1 = 3
     - 检查点(1,3)，在哈希表中找到，计数+1
   - 点(5,2)添加到哈希表
   - 哈希表：{(1,2): 1, (4,2): 1, (1,3): 1, (5,2): 1}，计数=2

最终答案为 2，表示有 2 对点的距离为 5，即(0,1)：因为(1 XOR 4) + (2 XOR 2) = 5 和(2,3)：因为(1 XOR 5) + (3 XOR 2) = 5。

## 复杂度分析

- **时间复杂度**：O(n \* k)，其中 n 是点的数量，k 是给定的距离值。对于每个点，我们需要枚举所有可能的 a 值（从 0 到 k）。
- **空间复杂度**：O(n)，用于存储哈希表，最坏情况下需要存储所有 n 个点。

## 总结

这道题巧妙地结合了异或运算的性质和哈希表的使用，将看似需要 O(n²)时间的问题优化到了 O(n \* k)。解题的关键在于理解异或运算的特性，以及如何通过数学转换将问题简化为检查特定点是否存在于已处理的点集合中。

这种解法不仅高效，而且实现起来也相对简单。通过枚举所有可能的距离分配方式（a 和 b 的组合），我们可以避免暴力检查所有点对，从而大大提高算法的效率。
