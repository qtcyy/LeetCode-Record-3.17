# LeetCode 2317. 操作后的最大异或和

## 题目理解

这道题给我们一个整数数组`nums`，我们可以对数组中的任意元素执行任意次操作：选择一个非负整数`x`和一个下标`i`，将`nums[i]`更新为`nums[i] AND (nums[i] XOR x)`。目标是执行任意次操作后，使数组所有元素的异或和最大化。

## 解题思路

要解决这个问题，首先需要分析操作`nums[i] = nums[i] AND (nums[i] XOR x)`对`nums[i]`的影响。

对于`nums[i]`的每一个二进制位，操作后的结果是：

- 如果该位是 0，操作后仍然是 0
- 如果该位是 1 且`x`对应位是 0，操作后仍然是 1
- 如果该位是 1 且`x`对应位是 1，操作后变为 0

这意味着通过选择合适的`x`，我们可以有选择地清除`nums[i]`中的某些 1 位，但不能将 0 位变为 1 位。

## 数学推导与证明

根据搜索结果，我们可以确认解决方案是计算数组所有元素的按位或(OR)。下面是关于为什么这种方法有效的数学证明：

### 操作分析

nums[i] AND (nums[i] XOR x)这个操作实际上是一种 1 位删除操作。不管右侧如何异或，左侧的 AND 操作只会保留原始数字中的 1 位。对于任何一位，我们都可以通过选择适当的 x 来删除任何 1 位。

具体分析每一位的情况：

1. 如果 nums[i]的某一位是 0，无论 x 对应位是什么，操作后该位仍为 0
2. 如果 nums[i]的某一位是 1 且 x 对应位是 0，操作后该位仍为 1
3. 如果 nums[i]的某一位是 1 且 x 对应位是 1，操作后该位变为 0

### 为什么最大异或和是按位或？

对于数组异或和的每一位，有如下特性：

1. 如果该位有奇数个 1，则异或结果为 1
2. 如果该位有偶数个 1，则异或结果为 0

而我们的操作可以选择性地删除任何位置的 1 位，这意味着：

- 对于原数组中某一位至少有一个 1 的情况，我们可以通过操作保留恰好一个 1（奇数个），使得异或结果为 1
- 对于原数组中某一位全为 0 的情况，无论如何操作，该位的异或结果只能为 0

所以，最大可能的异或和就是一个数，它的每一位在原数组对应位至少有一个 1 时为 1，否则为 0。这正好是数组所有元素的按位或(OR)结果。

## 算法复杂度

- **时间复杂度**：O(n)，其中 n 是数组长度，我们只需要遍历一次数组计算按位或结果。
- **空间复杂度**：O(1)，只需要一个变量存储按位或结果。

## 示例演示

以例子`nums = [3, 2, 4, 6]`为例：

- 3 的二进制表示：`011`
- 2 的二进制表示：`010`
- 4 的二进制表示：`100`
- 6 的二进制表示：`110`

按位或结果：`111`，即十进制的 7。

通过应用操作，我们可以得到如下数组：`[3, 2, 4, 2]`（对第 4 个元素 6 应用 x=4 的操作）。
这个数组的异或和为：`3 XOR 2 XOR 4 XOR 2 = 7`。

## 总结

这道题的关键洞察是理解操作`nums[i] = nums[i] AND (nums[i] XOR x)`实际上允许我们选择性地删除任何元素中的任何 1 位，但不能添加原本没有的 1 位。因此，最大可能的异或和就是所有元素的按位或结果，这确保了在至少有一个元素在某位上有 1 的情况下，最终异或和在该位上也能得到 1。
