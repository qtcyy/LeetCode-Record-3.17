# LeetCode 2564. 子字符串异或查询 - 解题思路

## 问题理解

我来解析一下这道子字符串异或查询题：

给定一个二进制字符串`s`和查询数组`queries`，每个查询包含两个整数`[first, second]`。对于每个查询，我们需要找到`s`中的最短子字符串，其十进制值`val`满足`val ^ first == second`。返回每个查询对应子字符串的起止位置，如果不存在则返回`[-1, -1]`。如果有多个答案，选择起始位置最小的。

## 解题思路

这个问题可以通过以下方式解决：

1. 对于每个查询`[first, second]`，我们需要找到值为`target = first ^ second`的子字符串
2. 枚举原字符串中所有可能的子字符串效率太低，我们可以预处理所有可能长度的子字符串

我们可以使用哈希表来存储所有可能的子字符串值及其位置，然后直接查询。由于整数范围限制，我们只需要考虑长度不超过 32 的子字符串。

让我实现这个算法：

## 代码详解

### 预处理阶段

1. 我们使用哈希表`mp`存储每个可能的子字符串十进制值到其位置（左右端点）的映射
2. 对于字符串中的每个位置`i`，我们尝试以该位置为起点构建所有可能的子字符串：
   - 特别处理以'0'开头的情况，因为单个'0'已经代表十进制值 0
   - 对于其他情况，我们从该位置开始，逐位构建子字符串的十进制值
   - 为避免整数溢出，我们使用`long long`类型
   - 我们只考虑长度不超过 32 的子字符串（因为整数最多 32 位）
3. 如果哈希表中还没有该值，或者当前子字符串比已存储的对应值子字符串更短，则更新映射

### 查询处理阶段

1. 对于每个查询`[first, second]`，计算目标值`target = first ^ second`
2. 在哈希表中查找是否存在值为`target`的子字符串
3. 如果存在，返回对应的位置；否则返回`[-1, -1]`

## 算法复杂度分析

- **时间复杂度**: O(n × 32 + q)，其中 n 是字符串长度，q 是查询数量
  - 预处理阶段需要 O(n × 32)时间
  - 查询处理阶段需要 O(q)时间
- **空间复杂度**: O(n × 32)，用于存储哈希表

## 关键优化点

1. **提前退出**：对于以'0'开头的子字符串，除了单个'0'外，我们可以跳过它们，因为相同值的非零开头的子字符串会更短
2. **长度限制**：只考虑长度不超过 32 的子字符串，因为整数的二进制表示最多 32 位
3. **选择最优解**：当有多个相同值的子字符串时，我们选择长度最短的，如果长度相同则选择起始位置最小的

## 例子演示

假设我们有字符串`s = "101"`和查询`queries = [[3, 4]]`：

1. 计算目标值：`target = 3 ^ 4 = 7`
2. 预处理字符串：
   - 子字符串"1"：值为 1
   - 子字符串"10"：值为 2
   - 子字符串"101"：值为 5
   - 没有值为 7 的子字符串
3. 查询处理：返回`[-1, -1]`

从网络搜索结果来看，我的解决方案与标准思路一致。让我来验证和优化一下：

## 优化细节

从搜索结果中的一些讨论，我发现了一个优化点：当处理以'0'开头的子字符串时，除了单个'0'外，我们不需要继续处理，因为以'0'开头的更长子字符串不会是最短的答案。这一点在我的代码中已经实现了：当遇到`s[i] == '0'`时，我们只记录单个'0'的位置，然后跳过当前起点。

此外，正如搜索结果所示，由于我们关注的是整数值，子字符串的长度不会超过 31（32 位整数，最高位是符号位）。

## Python 版本的解法

我也可以提供一个 Python 版本的解法，以供参考：

## 测试用例分析

让我们分析几个测试用例，以验证算法的正确性：

### 示例 1

```
s = "101101", queries = [[0,5],[1,2]]
```

1. 对于查询[0,5]：

   - 目标值 = 0 ^ 5 = 5
   - 字符串中有子字符串"101"（位置[0,2]），十进制值为 5
   - 返回[0,2]

2. 对于查询[1,2]：
   - 目标值 = 1 ^ 2 = 3
   - 字符串中有子字符串"11"（位置[2,3]），十进制值为 3
   - 返回[2,3]

### 示例 2

```
s = "1", queries = [[4,5]]
```

1. 对于查询[4,5]：
   - 目标值 = 4 ^ 5 = 1
   - 字符串中有子字符串"1"（位置[0,0]），十进制值为 1
   - 返回[0,0]

## 性能优化注意事项

从搜索结果中可以看出，当输入规模较大时，可能会遇到超时问题。为避免这种情况，我们应该：

1. 确保正确处理以'0'开头的特殊情况
2. 对于超过 32 位的数值，不需要继续计算
3. 使用哈希表快速查找目标值

## 总结

这道题的关键在于理解异或运算的性质（`a ^ b = c` 等价于 `a = b ^ c`）以及对所有可能的子字符串进行预处理。通过以下步骤解决：

1. 预处理阶段：计算所有可能的子字符串的十进制值，并记录其位置
2. 查询处理阶段：对于每个查询[first, second]，计算目标值 target = first ^ second，然后在预处理的结果中查找

这种方法的时间复杂度为 O(n × 32 + q)，空间复杂度为 O(n × 32)，可以高效地解决这个问题。
