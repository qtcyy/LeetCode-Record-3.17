# LeetCode 2997. 使数组异或和等于 K 的最少操作次数

## 题目理解

题目给定一个整数数组`nums`和一个正整数`k`，我们可以对数组中的任意元素进行操作：翻转任意一个元素的任意一个二进制位（0 变 1 或 1 变 0），包括前导 0。目标是使数组所有元素的异或和等于`k`，求达成目标的最少操作次数。

## 解题思路

要解决这个问题，需要利用异或运算的特性。首先，计算数组当前的异或和，然后与目标值`k`比较，找出需要改变的位。

关键观察：

- 对于数组中某个元素的某一位进行翻转，会导致整个数组异或和的对应位也发生翻转
- 对于每个需要改变的位，我们只需要选择一个元素进行翻转即可

## 算法详解与证明

### 为什么这个算法是正确的？

1. **异或运算的基本性质**：

   - 如果 a ^ b = c，那么 a ^ c = b
   - 异或运算满足交换律和结合律

2. **问题转化**：

   - 令 `current_xor` 为数组当前的异或和
   - 我们的目标是通过一系列操作使得 `current_xor` 变为 `k`
   - 如果我们定义 `diff = current_xor ^ k`，那么 `diff` 中的每个 1 位都表示需要进行翻转的位

3. **最优策略**：
   - 对于 `diff` 中的每个 1 位，我们只需在数组中选择一个元素，翻转其对应位即可
   - 因为翻转一个元素的一位会导致整个数组异或和的对应位也发生翻转
   - 所以最少的操作次数就是 `diff` 中 1 的个数

### 复杂度分析

- **时间复杂度**: O(n + log(max(nums, k)))

  - 计算异或和需要 O(n) 时间
  - 计算二进制中 1 的个数需要 O(log(diff)) 时间，其中 diff 最大为 max(nums, k)

- **空间复杂度**: O(1)
  - 只需要几个变量来存储中间结果

## 示例演示

让我们用一个例子来说明：

```
nums = [1, 2, 3], k = 4
```

1. 计算当前异或和：`current_xor = 1 ^ 2 ^ 3 = 0`

   - 1 的二进制是 `001`
   - 2 的二进制是 `010`
   - 3 的二进制是 `011`
   - 异或结果是 `000`

2. 计算差异：`diff = current_xor ^ k = 0 ^ 4 = 4`

   - 0 的二进制是 `000`
   - 4 的二进制是 `100`
   - 异或结果是 `100`

3. 计算 `diff` 中 1 的个数：1

所以，要使数组异或和变为 4，我们需要进行 1 次操作。例如，可以将 3（`011`）变为 7（`111`），这样新的异或和就是 `1 ^ 2 ^ 7 = 4`。

## 总结

这个问题的关键在于理解异或运算的性质以及如何最少的操作次数使数组的异或和达到目标值。通过计算当前异或和与目标值的差异（即异或结果），我们可以确定需要翻转的位数，这就是最少的操作次数。

这种方法非常高效，因为我们不需要实际执行翻转操作，只需计算需要翻转的位数即可。
