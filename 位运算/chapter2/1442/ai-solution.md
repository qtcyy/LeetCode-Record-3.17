# LeetCode 1442. 形成两个异或相等数组的三元组数目

## 题目理解

题目要求我们找到数组中的三元组 (i, j, k) 满足条件：

- 0 <= i < j <= k < arr.length
- a = arr[i] ^ arr[i+1] ^ ... ^ arr[j-1]
- b = arr[j] ^ arr[j+1] ^ ... ^ arr[k]
- a == b

也就是说，我们需要找到使两个子数组的异或值相等的三元组数目。

## 解题思路

对于这类异或问题，使用前缀异或数组是一种常用的技巧。通过前缀异或数组，我们可以在 O(1)时间内计算任意子数组的异或值。

关键发现：

- 如果 a == b，那么 a ^ b = 0
- 也就是说，数组 arr[i] 到 arr[k] 的异或值为 0

这意味着我们需要找到满足以下条件的 (i, k) 对：

- arr[i] ^ arr[i+1] ^ ... ^ arr[k] = 0
- 对于每对满足条件的 (i, k)，每个 j 满足 i < j <= k 都能形成一个有效的三元组

## 算法详解

### 前缀异或数组的应用

前缀异或数组`prefix`定义为：

- prefix[0] = 0
- prefix[i] = arr[0] ^ arr[1] ^ ... ^ arr[i-1]（对于 i ≥ 1）

使用前缀异或数组，我们可以计算任意子数组[i, j]的异或和：

- arr[i] ^ arr[i+1] ^ ... ^ arr[j] = prefix[j+1] ^ prefix[i]

### 条件推导

根据题目条件，我们要找三元组(i, j, k)，使得：

- a = arr[i] ^ arr[i+1] ^ ... ^ arr[j-1] = prefix[j] ^ prefix[i]
- b = arr[j] ^ arr[j+1] ^ ... ^ arr[k] = prefix[k+1] ^ prefix[j]

如果 a == b，则：

- prefix[j] ^ prefix[i] = prefix[k+1] ^ prefix[j]

经过简化（利用异或的性质：x ^ x = 0）：

- prefix[i] = prefix[k+1]

这意味着，当且仅当 prefix[i] = prefix[k+1]时，我们有：

- arr[i] ^ arr[i+1] ^ ... ^ arr[k] = 0

### 计数方法

对于每一对满足 prefix[i] = prefix[k+1]的(i, k)，我们可以选择 i < j <= k 范围内的任意位置 j 作为分割点，这样的 j 有(k-i)个。

### 复杂度分析

- **时间复杂度**：O(n²)，其中 n 是数组长度。我们需要检查所有可能的(i, k)对。
- **空间复杂度**：O(n)，用于存储前缀异或数组。

## 示例演示

以数组 arr = [2, 3, 1, 6, 7]为例：

1. 计算前缀异或数组：

   - prefix[0] = 0
   - prefix[1] = 0 ^ 2 = 2
   - prefix[2] = 2 ^ 3 = 1
   - prefix[3] = 1 ^ 1 = 0
   - prefix[4] = 0 ^ 6 = 6
   - prefix[5] = 6 ^ 7 = 1

2. 检查所有(i, k)对：
   - 当 i=0, k=2 时：prefix[0]=0, prefix[3]=0，满足条件
     - 有效的 j：j=1, j=2，共计 2 个三元组
   - 当 i=2, k=4 时：prefix[2]=1, prefix[5]=1，满足条件
     - 有效的 j：j=3, j=4，共计 2 个三元组

总共有 4 个有效三元组：(0,1,2), (0,2,2), (2,3,4), (2,4,4)

## 优化思路

虽然 O(n²)的解法已经相当高效，但在某些情况下，我们可以通过哈希表进一步优化。通过存储每个前缀异或值出现的所有位置，我们可以更快地找到满足条件的(i, k)对。这种优化在前缀异或值重复较多的情况下特别有效。

## 总结

这个问题的关键在于使用前缀异或数组技术，并找出满足特定条件的子数组。通过数学推导，我们将问题简化为找前缀异或值相等的位置对，极大地降低了问题的复杂度。
