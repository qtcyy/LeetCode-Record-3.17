# LeetCode 1162 地图分析 - 解题分析

## 问题描述

给定一个包含 0（海洋）和 1（陆地）的二维网格，找出海洋格子到陆地格子的最大距离。距离定义为曼哈顿距离。

## 原代码问题分析

### 问题所在

原代码使用的是**单源 BFS**方法：

- 对每个海洋格子（grid[i][j] == 0）都进行一次 BFS
- 每次 BFS 都要搜索整个网格来找到最近的陆地
- 时间复杂度：O(n^4)，其中 n 是网格的边长

### 为什么会超时

- 网格大小为 n×n，海洋格子数量最多为 n²
- 每个海洋格子都要进行一次 BFS，每次 BFS 时间复杂度为 O(n²)
- 总时间复杂度为 O(n² × n²) = O(n⁴)
- 当 n=100 时，需要执行约 10⁸ 次操作，容易超时

## 正确解法：多源 BFS

### 核心思路

将所有陆地作为**起点**，同时进行 BFS，一层一层地向外扩散到海洋。

### 算法流程

1. **初始化**：将所有陆地格子加入队列，距离为 0
2. **边界检查**：如果全是陆地或全是海洋，返回-1
3. **多源 BFS**：
   - 从队列中取出一个格子
   - 向四个方向扩散
   - 如果邻居是海洋且未访问过，则加入队列，距离+1
   - 更新最大距离
4. **返回结果**：返回记录的最大距离

### 关键优化点

- **多源同时进行**：所有陆地同时作为起点，避免重复计算
- **原地标记**：直接修改 grid 数组标记访问状态，节省空间
- **层次遍历**：BFS 保证第一次访问到的距离就是最短距离

### 时间复杂度分析

- 每个格子最多被访问一次
- 时间复杂度：O(n²)
- 空间复杂度：O(n²)（队列最大长度）

### 算法可视化

```
初始状态：     第1层：      第2层：      第3层：
1 0 0 0       1 1 0 0     1 1 2 0     1 1 2 3
0 0 0 0  -->  1 0 0 0 --> 1 1 0 0 --> 1 1 2 0
0 0 0 1       0 0 1 1     0 1 1 1     1 1 1 1
0 0 0 0       0 0 0 1     0 0 1 1     0 1 1 1
```

数字表示该格子到最近陆地的距离，最大距离为 3。

## 总结

- 原代码问题：对每个海洋格子单独 BFS，时间复杂度过高
- 正确解法：多源 BFS，将所有陆地作为起点同时扩散
- 关键优化：避免重复计算，一次遍历解决所有海洋格子的最短距离问题
