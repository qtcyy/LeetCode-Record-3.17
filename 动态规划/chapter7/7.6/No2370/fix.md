# LeetCode 2370 - 最长理想子序列分析

## 问题理解

这道题要求找到一个字符串 s 的最长子序列 t，使得 t 中任意两个相邻字符在字母表中的位次绝对差值不超过 k。

## 代码分析

现有代码存在以下问题：

1. **范围处理错误**：在循环 `for j in range(-k, k + 1)` 中，使用 `(x + j) % 26` 计算字符位置时可能会产生负数索引，这是因为在 Python 中 `-1 % 26 = 25`（而不是简单地取模为-1）。对于这个问题，这不是正确的处理方式。

2. **不必要的搜索范围**：代码试图检查所有与当前字符差值在 -k 到 k 范围内的字符，但问题只关注子序列中相邻字符之间的差值。当前实现会导致计算出错。

3. **状态转移方程理解问题**：当前代码试图找到所有符合差值要求的之前的字符，但实际上我们需要检查的是哪些之前的字符可以作为当前字符的前一个字符。

## 修正后的思路

1. 对于每个位置 i 的字符，我们需要检查字母表中与当前字符差值不超过 k 的所有字符的最后出现位置。
2. 状态转移方程应该是：`f[i] = max(f[last[j]] + 1)` 其中 j 是所有与当前字符差值不超过 k 的字符。

## 修正后的代码

```python
class Solution:
    def longestIdealString(self, s: str, k: int) -> int:
        n = len(s)
        # f[i] 表示以索引 i 处字符结尾的最长理想子序列长度
        f = [1] * n
        # last[c] 表示字符 c 最后出现的位置（0-25 对应 a-z）
        last = [-1] * 26

        for i, char in enumerate(s):
            curr_char_idx = ord(char) - ord('a')

            # 检查所有与当前字符差值不超过 k 的字符
            for prev_char_idx in range(26):
                if abs(curr_char_idx - prev_char_idx) <= k and last[prev_char_idx] != -1:
                    f[i] = max(f[i], f[last[prev_char_idx]] + 1)

            # 更新当前字符的最后位置
            last[curr_char_idx] = i

        return max(f)
```

## 错误原因总结

原代码中的主要问题是对字符差值范围的处理方式不正确。通过循环 `-k` 到 `k` 并使用 `(x + j) % 26` 来计算位置，可能导致检查了错误的字符位置。正确的做法是直接遍历所有 26 个字母，检查与当前字符的绝对差值是否在 k 范围内。
