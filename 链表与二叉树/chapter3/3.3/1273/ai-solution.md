# LeetCode 1273. 删除树节点 解析

## 问题理解

题目给我们一棵以节点 0 为根的树，每个节点有一个值。我们需要删除所有节点值之和为 0 的子树，然后返回删除操作后剩余节点的数量。

输入信息包括：

- 节点总数 `nodes`
- 每个节点的值 `value[i]`
- 每个节点的父节点 `parent[i]`（其中 `parent[0]` 不使用，因为节点 0 是根节点）

## 解题思路

这是一个典型的树形 DFS 问题。我们需要：

1. 根据 `parent` 数组构建树的邻接表
2. 自底向上计算每棵子树的节点值之和
3. 如果某个子树的节点值之和为 0，则删除整棵子树
4. 计算剩余节点的数量

关键点是处理删除操作的传播：如果一个节点被删除，那么它的所有子节点也应该被删除。

## 代码实现

## Python 实现

```python
class Solution:
    def deleteTreeNodes(self, nodes: int, parent: List[int], value: List[int]) -> int:
        # 构建树结构（邻接表）
        tree = [[] for _ in range(nodes)]
        for i in range(1, nodes):
            tree[parent[i]].append(i)

        # DFS函数，返回(子树节点值之和, 剩余节点数量)
        def dfs(node):
            subtree_sum = value[node]  # 当前节点的值
            count = 1                 # 当前节点计数为1

            # 遍历所有子节点
            for child in tree[node]:
                child_sum, child_count = dfs(child)
                subtree_sum += child_sum    # 累加子树的和
                count += child_count        # 累加子树的节点数

            # 如果子树节点值之和为0，则整棵子树被删除
            if subtree_sum == 0:
                return 0, 0

            return subtree_sum, count

        # 从根节点开始DFS，返回第二个值（剩余节点数量）
        return dfs(0)[1]
```

## 算法复杂度分析

- **时间复杂度**: $O(n)$，其中 $n$ 是节点数量。我们需要遍历每个节点一次。
- **空间复杂度**: $O(n)$，用于存储树的邻接表和递归调用栈的空间。

## 算法解释

1. **构建树结构**：

   - 使用邻接表表示树，其中 `tree[i]` 存储节点 `i` 的所有子节点

2. **DFS 函数**：

   - 输入：当前节点的索引
   - 返回：一个包含两个值的元组/对 `{子树节点值之和, 剩余节点数量}`
   - 首先计算当前节点的值
   - 然后递归处理所有子节点，累加子树的和和节点数
   - 如果子树的和为 0，返回 `{0, 0}` 表示整棵子树都被删除
   - 否则返回 `{sum, count}` 表示子树的和和剩余节点数

3. **主函数处理**：
   - 从根节点(节点 0)开始 DFS
   - 返回 DFS 结果的第二个值，即剩余节点数量

## 示例分析

以测试用例 `nodes = 7, parent = [-1,0,0,1,2,2,2], value = [1,-2,4,0,-2,-1,-1]` 为例：

树的结构如下：

```
    0(1)
   / \
 1(-2) 2(4)
 /    /|\
3(0) 4(-2) 5(-1) 6(-1)
```

DFS 执行过程：

- 节点 3: 值为 0，返回 `{0, 1}`
- 节点 4: 值为-2，返回 `{-2, 1}`
- 节点 5: 值为-1，返回 `{-1, 1}`
- 节点 6: 值为-1，返回 `{-1, 1}`
- 节点 2: 值为 4，子节点和为-4，总和为 0，返回 `{0, 0}`(整棵子树删除)
- 节点 1: 值为-2，子节点和为 0，总和为-2，返回 `{-2, 2}`
- 节点 0: 值为 1，子节点 1 的和为-2，子节点 2 被删除(和为 0)，总和为-1，返回 `{-1, 3}`

最终剩余节点数为 3（节点 0、1 和 3）。

## 总结

这道题的关键是理解递归删除子树的过程。使用后序遍历（先处理子节点，再处理当前节点）可以高效地计算子树和并判断是否需要删除。通过返回一个包含多个信息的结构体/元组，我们可以在一次 DFS 中同时计算子树和并统计剩余节点数。
